<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Funcky User Guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><strong aria-hidden="true">1.</strong> Case Studies</li><li><ol class="section"><li class="chapter-item expanded "><a href="case-studies/if-null-to-option.html"><strong aria-hidden="true">1.1.</strong> Simplify if null by using an Option</a></li></ol></li><li class="chapter-item expanded "><a href="option.html"><strong aria-hidden="true">2.</strong> Option Monad</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="try-pattern.html"><strong aria-hidden="true">2.1.</strong> The TryVerb-pattern</a></li><li class="chapter-item expanded "><strong aria-hidden="true">2.2.</strong> The Linq-Extensions</li><li><ol class="section"><li class="chapter-item expanded "><strong aria-hidden="true">2.2.1.</strong> FirstOrNone, LastOrNone, SingleOrNone</li><li class="chapter-item expanded "><strong aria-hidden="true">2.2.2.</strong> WhereSelect</li></ol></li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">3.</strong> Either Monad</li><li class="chapter-item expanded "><strong aria-hidden="true">4.</strong> Result Monad</li><li class="chapter-item expanded "><a href="functional-helpers/functional-helpers.html"><strong aria-hidden="true">5.</strong> Functional Helpers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functional-helpers/no-operation.html"><strong aria-hidden="true">5.1.</strong> NoOperation</a></li><li class="chapter-item expanded "><a href="functional-helpers/identity.html"><strong aria-hidden="true">5.2.</strong> Identity</a></li><li class="chapter-item expanded "><strong aria-hidden="true">5.3.</strong> Curry</li><li class="chapter-item expanded "><strong aria-hidden="true">5.4.</strong> Flip</li><li class="chapter-item expanded "><strong aria-hidden="true">5.5.</strong> Retry</li><li class="chapter-item expanded "><strong aria-hidden="true">5.6.</strong> Predicate Composition</li><li class="chapter-item expanded "><a href="functional-helpers/unit-type.html"><strong aria-hidden="true">5.7.</strong> Unit Type</a></li><li class="chapter-item expanded "><a href="functional-helpers/action-to-unit.html"><strong aria-hidden="true">5.8.</strong> ActionToUnit</a></li></ol></li><li class="chapter-item expanded "><a href="enumerable-extensions/enumerable-extensions.html"><strong aria-hidden="true">6.</strong> IEnumerable Extensions</a></li><li class="chapter-item expanded "><a href="string-extensions.html"><strong aria-hidden="true">7.</strong> String Extensions</a></li><li class="chapter-item expanded "><strong aria-hidden="true">8.</strong> Stream Extensions</li><li class="chapter-item expanded affix "><a href="changelog.html">Changelog</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Funcky User Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/polyadic/funcky" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>Functional programming is the oldest of the three major programming paradigms, none the less it is the last which gets wide spread usage. Even in languages like C++, Java or C# we want to use a functional style of programming.</p>
<p>Linq is the first Monad which got wide spread use in C#, and most C# programmers were not even aware of it beeing a monad, which probably helped.</p>
<p><a href="https://blog.ploeh.dk/2019/02/04/how-to-get-the-value-out-of-the-monad/">Mark Seemann</a> points out that &quot;Unfortunately, Maybe implementations often come with an API that enables you to ask a Maybe object if it's populated or empty, and a way to extract the value from the Maybe container. This misleads many programmers [...]&quot;</p>
<p>This library is based on his example code, and should grow slowly to a library which helps to use and understand the Functional programming paradigm. Functional programming is side-effect free and the strong type system can be used to make illegal state impossible.</p>
<p>Use functional programming as an additional asset to write correct code.</p>
<h1><a class="header" href="#simplify-if-null-by-using-an-option" id="simplify-if-null-by-using-an-option">Simplify <code>if null</code> by using an <code>Option</code></a></h1>
<p>We start off with the following code:
(Note that some types have been omitted for brevity)</p>
<pre><code class="language-csharp">#nullable enable

using System;

public class Example
{
    public VersionEnvironment? GetCurrentVersionEnvironment(PackageName packageName)
    {
        var currentVersion = ReadCurrentVersion(packageName);

        if (currentVersion is null)
        {
            return null;
        }

        var versionPath = GetVersionPath(packageName, currentVersion);
        return new VersionEnvironment(currentVersion, versionPath);
    }

    public PackageVersion? ReadCurrentVersion(PackageName name) =&gt; null; // Real implementation omitted

    public string GetVersionPath(PackageName name, PackageVersion version) =&gt; null!; // Real implementation omitted
}
</code></pre>
<p>The function <code>GetCurrentVersionEnvironment</code> doesn't do much, but it's not pleasant to look at,
because of that early return condition.</p>
<h2><a class="header" href="#step-‚Ö†" id="step-‚Ö†">Step ‚Ö†</a></h2>
<p>We start off by changing the return type of <code>ReadCurrentVersion</code> from <code>PackageVersion?</code> to an <code>Option</code>:</p>
<pre><code class="language-csharp">public Option&lt;PackageVersion&gt; ReadCurrentVersion(PackageName name) =&gt; Option.None&lt;PackageVersion&gt;(); // Real implementation omitted
</code></pre>
<h2><a class="header" href="#step-‚Ö°" id="step-‚Ö°">Step ‚Ö°</a></h2>
<p>This immediately breaks the <code>GetCurrentVersionEnvironment</code>, because our <code>null</code> check no longer makes sense.
Instead of checking for <code>null</code> and returning early, we can use <code>Select</code> on the <code>Option</code> to project its value.</p>
<pre><code class="language-csharp">public Option&lt;VersionEnvironment&gt; GetCurrentVersionEnvironment(PackageName packageName)
{
    return ReadCurrentVersion(packageName)
        .Select(currentVersion =&gt; {
            var versionPath = GetVersionPath(packageName, currentVersion);
            return new VersionEnvironment(currentVersion, versionPath);
        });
}
</code></pre>
<h2><a class="header" href="#step-‚Ö¢" id="step-‚Ö¢">Step ‚Ö¢</a></h2>
<p>This is already much simpler, since we've got rid of that explicit null check.</p>
<p>There's still room for simplification, since our projection takes up two lines and we ideally only want a single expression in our projection.</p>
<p>We can achieve this by translating our expression to query syntax:</p>
<pre><code class="language-csharp">public Option&lt;VersionEnvironment&gt; GetCurrentVersionEnvironment(PackageName packageName)
{
    return from currentVersion in ReadCurrentVersion(packageName)
           let versionPath = GetVersionPath(packageName, currentVersion)
           select new VersionEnvironment(currentVersion, versionPath);
}
</code></pre>
<h2><a class="header" href="#step-‚Ö£" id="step-‚Ö£">Step ‚Ö£</a></h2>
<p>Since our method now consists of only one expression, we can make it an expression body:</p>
<pre><code class="language-csharp">public Option&lt;VersionEnvironment&gt; GetCurrentVersionEnvironment(PackageName packageName)
    =&gt; return from currentVersion in ReadCurrentVersion(packageName)
              let versionPath = GetVersionPath(packageName, currentVersion)
              select new VersionEnvironment(currentVersion, versionPath);
</code></pre>
<h1><a class="header" href="#option-monad" id="option-monad">Option Monad</a></h1>
<h2><a class="header" href="#what-is-the-option-monad" id="what-is-the-option-monad">What is the Option Monad</a></h2>
<p>The Option Monad is a very simple <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic type</a> which is a fancy way to say you can have more than one different type of data in it. The Option monad is a combination of a value of a type and a second type which can only be one value: <code>None</code>. The state of the option monad is always either None, or Some with a certain value of a type you can chose. It means it can hold any value of your chosen type + None state.</p>
<p>This is very similar to references which can be <code>null</code> or <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types">Nullable Value Types</a> which adds the &quot;has no value&quot;-concept to value types.</p>
<p>However the main issue with references and <code>Nullable&lt;T&gt;</code> is, before every access you need to check if the value is accessible. The Option Monad is an abstraction which removes all this boilerplate code, in a save way.</p>
<h3><a class="header" href="#create-something" id="create-something">Create something</a></h3>
<pre><code class="language-csharp">var something = Option.Some(1337);
</code></pre>
<h3><a class="header" href="#create-nothing" id="create-nothing">Create nothing</a></h3>
<pre><code class="language-csharp">var nothing = Option&lt;int&gt;.None();
</code></pre>
<h3><a class="header" href="#select" id="select">Select</a></h3>
<pre><code class="language-csharp">Option&lt;bool&gt; maybeBool =
    from m in maybe
    select m == 1337;
</code></pre>
<h3><a class="header" href="#select-many" id="select-many">Select Many</a></h3>
<pre><code class="language-csharp">var result = from number in someNumber
    from date in someDate
    select Tuple.Create(number, date);
</code></pre>
<h3><a class="header" href="#match" id="match">Match</a></h3>
<pre><code class="language-csharp">bool isSome = maybe.Match(
    none: false,
    some: m =&gt; true
);
</code></pre>
<h2><a class="header" href="#how-can-i-get-the-value" id="how-can-i-get-the-value">How can I get the value?</a></h2>
<p>If you declare</p>
<pre><code class="language-cs">int? integer = 1337;
</code></pre>
<p>You can access the Value directly via <code>i.Value</code>. The typical beginner question on the monad is therefore how to get to the value in a monad.</p>
<p>The Option-Monad intentionally has no way to get to the value directly because that would be an unsafe operation. The whole point of an optional is that it sometimes has no value. Instead you should inject the behaviour into the monad.</p>
<p>The basic Example:</p>
<pre><code class="language-cs">int? integer = MaybeValue();

if (integer.HasValue())
{
    Console.WriteLine($&quot;Value: {integer.Value}&quot;);
}
</code></pre>
<p>Injecting the behaviour:</p>
<pre><code class="language-cs">Option&lt;int&gt; integer = MaybeValue();

integer
  .AndThen(i =&gt; Console.WriteLine($&quot;Value: {i}&quot;));
</code></pre>
<p>Or in Linq syntax:</p>
<pre><code class="language-cs">from integer in MaybeValue()
select Console.WriteLine($&quot;Value: {integer.Value}&quot;);
</code></pre>
<h1><a class="header" href="#the-tryverb-pattern" id="the-tryverb-pattern">The TryVerb-pattern</a></h1>
<p>The TryVerb pattern is used in several instances in C# as an alternative for functions which throw an exception. </p>
<p><code>Parse</code> throws an exception if <code>inputString</code> is not a number.</p>
<pre><code class="language-cs">var number = int.Parse(inputString);
</code></pre>
<p><code>TryParse</code> returns <code>false</code> in such a case, so the number is always correct if <code>TryParse</code> returns <code>true</code>. This means you have to check the return value before accessing number.</p>
<pre><code class="language-cs">if (int.TryParse(inputString, out number)) 
{
    // ...
}
</code></pre>
<p>Out parameters are bad, and in consequence we think the TryVerb-pattern (<code>TryGet</code>, <code>TryParse</code>...) used in C# as an anti-pattern.</p>
<p>We have added an overload for each and every &quot;Try&quot; function we have found in the .NET Framework and we give an alternative in the Form <Verb>OrNone.</p>
<h2><a class="header" href="#getvalueornone" id="getvalueornone">GetValueOrNone</a></h2>
<p>Extension functions have been added to <code>IDictionary</code> and <code>IReadOnlyDictionary</code></p>
<h2><a class="header" href="#getvaluesornone" id="getvaluesornone">GetValuesOrNone</a></h2>
<h2><a class="header" href="#the-parse-functions" id="the-parse-functions">The parse functions</a></h2>
<pre><code class="language-cs">Option&lt;int&gt; = &quot;1234&quot;.ParseIntOrNone();
</code></pre>
<p>The static class <code>Funcky.Functional</code> is designed to be used with a static import (<code>using static Funcky.Functional;</code>). All examples will be as if <code>using static</code> was used.
All the methods in <code>Funcky.Functional</code> are named to be easily understood without the functional prefix. They are general purpose, and their goal is to unify typical boilerplate code or be more expressive than typical C# ways of doing their job.</p>
<p>The <code>NoOperation</code> function is a more expressive way of manually creating an empty statement as a parameter to a method expecting a <code>Action</code>/<code>Action&lt;T&gt;</code>, supporting from 0 up to 8 generic parameters.</p>
<p>Example 1:</p>
<pre><code class="language-csharp">// The function we want to call:
public void DoSomething(int value, Action&lt;int&gt; callback)
{
  // ...
}

// How we would usually call it when we don't need the callback:
DoSomething(2, _ =&gt; {});

// How you can call it with NoOperation:
DoSomething(2, NoOperation);
</code></pre>
<p><code>NoOperation</code> becomes especially useful when a <code>Action&lt;T&gt;</code> with many parameters is expected.</p>
<p>Example 2:</p>
<pre><code class="language-csharp">// The function we want to call:
public void DoSomething(int value, Action&lt;int, string, float, AnyCustomClassThatYouWant&gt; callback)
{
  // ...
}

// How we would usually call it when we don't need the callback (C#9):
DoSomething(2, (_, _, _, _) =&gt; {});
// Before C#9, this was even worse:
DoSomething(3, (_, __, ___, ____) =&gt; {});

// How you can call it with NoOperation:
DoSomething(2, NoOperation);
</code></pre>
<p><code>NoOperation</code> is also useful when you want to use a expression body for a method.</p>
<p>Example 3:</p>
<pre><code class="language-csharp">// Abstract class:
public abstract class SomeClassWithExecuteAndHookBase
{
  public void Execute();
  
  protected abstract void PostExecutionHook();
}

// Derived class that doesn't have any use for the PostExecutionHook usually:
public class SomeClassWithExecuteAndHookDerived : SomeClassWithExecuteAndHookBase
{
  protected override void PostExecutionHook()
  {
  }
}

// Derived class that doesn't have any use for the PostExecutionHook with NoOperation:
public class SomeClassWithExecuteAndHookDerived : SomeClassWithExecuteAndHookBase
{
  protected override void PostExecutionHook() =&gt; NoOperation();
}
</code></pre>
<p>The <code>Identity</code> function is designed to replace parameter-returning lambdas, like sometimes used in LINQ.</p>
<p>Example 1:</p>
<pre><code class="language-csharp">// Method:
public void FunctionExpectingSelector&lt;TIn, TOut&gt;(Func&lt;TIn, TOut&gt; selector)
{
  // ...
}

// Usually:
FunctionExpectingSelector(x =&gt; x);
// Or:
FunctionExpectingSelector(item =&gt; item);

// With Identity:
FunctionExpectingSelector(Identity);
</code></pre>
<p>Example 2 (typical <code>SelectMany</code> selector):</p>
<pre><code class="language-csharp">// Usually result of a query:
IEnumerable&lt;IEnumerable&lt;int&gt;&gt; itemGroups = new[] { new[] { 1, 2, 3 }, new[] { 5, 6, 7 } };

// Goal: Get all items flattened.
// Common approach:
itemGroups.SelectMany(x =&gt; x);
// Or:
itemGroups.SelectMany(items =&gt; items);

// With Identity:
itemGroups.SelectMany(Identity);
</code></pre>
<p>The unit type is an alternative to the native C# struct <code>Void</code> (with the global alias <code>void</code>).</p>
<p>The C# compiler handles <code>Void</code>/<code>void</code> very different to all other types in C#:</p>
<ul>
<li><code>Void</code> can never be used. You must always use <code>void</code></li>
<li><code>void</code> can not be instantiated</li>
<li><code>void</code> can not be used as a generic argument to any function</li>
<li>A function (sometimes also called method) &quot;returning&quot; <code>void</code> does not return a value, and the result of the function (<code>void</code>) can not be assigned to any variable</li>
<li>When using reflection, void-methods will return <code>null</code> because the compiler can not know during compile-time what the dynamically dispatched method will return</li>
</ul>
<p>These limitations on the void type introduce annoying behaviour, especially with expressions and generics.</p>
<h2><a class="header" href="#example-1---the-void-is-not-a-real-type-dilemma" id="example-1---the-void-is-not-a-real-type-dilemma">Example 1 - the &quot;void is not a real type&quot; dilemma:</a></h2>
<p>This examples uses a simple algebraic datatype with a generic match method:</p>
<pre><code class="language-csharp">public abstract class SimpleAlgebraicDatatype
{
	private SimpleAlgebraicDatatype()
	{
	}

	public abstract TResult Match&lt;TResult&gt;(
		Func&lt;Variant1, TResult&gt; variant1,
		Func&lt;Variant2, TResult&gt; variant2);

	public class Variant1 : SimpleAlgebraicDatatype
	{
		public Variant1(string someValue)
		{
			SomeValue = someValue;
		}
		
		public string SomeValue { get; }

		public override TResult Match&lt;TResult&gt;(
			Func&lt;Variant1, TResult&gt; variant1, 
			Func&lt;Variant2, TResult&gt; variant2)
			=&gt; variant1(this);
	}

	public class Variant2 : SimpleAlgebraicDatatype
	{
		public Variant2(int someValue)
		{
			SomeValue = someValue;
		}
		
		public int SomeValue { get; }

		public override TResult Match&lt;TResult&gt;(
			Func&lt;Variant1, TResult&gt; variant1, 
			Func&lt;Variant2, TResult&gt; variant2)
			=&gt; variant2(this);
	}
}
</code></pre>
<p>It then can be used like that:</p>
<pre><code class="language-csharp">SimpleAlgebraicDatatype variant = new SimpleAlgebraicDatatype.Variant1(&quot;Hey&quot;);
// get the variant as string
var value = variant.Match(
	variant1: variant1 =&gt; variant1.SomeValue,
	variant2: variant2 =&gt; Convert.ToString(variant2.SomeValue));
Console.WriteLine(value);
</code></pre>
<p>But if you don't want to use the return value, you're stuck with returning a value you don't want.
This does <strong>not</strong> compile:</p>
<pre><code class="language-csharp">// Error [CS0411] The type arguments for method 'method' cannot be inferred from the usage. Try specifying the type arguments explicitly.
variant.Match(
	variant1: variant1 =&gt; Console.Write(variant1.SomeValue),
	variant2: variant2 =&gt; Console.Write(Convert.ToString(variant2.SomeValue)));
</code></pre>
<p>Now you have to decide what it returns. One option is to return null - the best fitting return type is probably <code>object?</code> in that case:</p>
<pre><code class="language-csharp">variant.Match&lt;object?&gt;(
	variant1: variant1 =&gt;
	{
		Console.Write(variant1.SomeValue);
		return null;
	},
	variant2: variant2 =&gt;
	{
		Console.Write(Convert.ToString(variant2.SomeValue));
		return null;
	});
</code></pre>
<p>This is very unstatisfying however. We have to trick the type-system. There should be a more expressive way.</p>
<p>Funcky.Unit to the rescue:</p>
<pre><code class="language-csharp">variant.Match(
	variant1: variant1 =&gt;
	{
		Console.Write(variant1.SomeValue);
		return Unit.Value;
	},
	variant2: variant2 =&gt;
	{
		Console.Write(Convert.ToString(variant2.SomeValue));
		return Unit.Value;
	});
</code></pre>
<p>Now this isn't really less noise. This is why we created <a href="functional-helpers/./action-to-unit.html">ActionToUnit</a>.</p>
<p>This clears up the code to:</p>
<pre><code class="language-csharp">variant.Match(
	variant1: variant1 =&gt; ActionToUnit(() =&gt; Console.Write(variant1.SomeValue)),
	variant2: variant2 =&gt; ActionToUnit(() =&gt; Console.Write(Convert.ToString(variant2.SomeValue))));
</code></pre>
<p>See <a href="functional-helpers/./action-to-unit.html">ActionToUnit</a> for an explanation.</p>
<h2><a class="header" href="#example-2---the-switch-expression-must-return-something-dilemma" id="example-2---the-switch-expression-must-return-something-dilemma">Example 2 - the &quot;switch expression must return something&quot; dilemma:</a></h2>
<p>The following two code snippes do <strong>not</strong> comple:</p>
<pre><code class="language-csharp">// Error [CS0201]: Only assignment, call, increment, decrement, and new object expressions can be used as a statement.
variant switch
{
	SimpleAlgebraicDatatype.Variant1 variant1 =&gt; Console.Write(variant1.SomeValue),
	SimpleAlgebraicDatatype.Variant2 variant2 =&gt; Console.Write(Convert.ToString(variant2.SomeValue)),
	_ =&gt; throw new Exception(&quot;Unreachable&quot;),
};

// Error [CS0029]: Cannot implicitly convert type 'thorw-expression' to 'void'
// Error [CS9209]: A value of type 'void' may not be assigned.
_ = variant switch
{
	SimpleAlgebraicDatatype.Variant1 variant1 =&gt; Console.Write(variant1.SomeValue),
	SimpleAlgebraicDatatype.Variant2 variant2 =&gt; Console.Write(Convert.ToString(variant2.SomeValue)),
	_ =&gt; throw new Exception(&quot;Unreachable&quot;),
};
</code></pre>
<p>One way to resolve this dilemma is to return a method that returns null from every arm, and execute it after:</p>
<pre><code class="language-csharp">// very verbose and not very readable
Func&lt;SimpleAlgebraicDatatype, object&gt; action = variant switch
{
	SimpleAlgebraicDatatype.Variant1 variant1 =&gt; _ =&gt;
	{
		Console.Write(Convert.ToString(variant1.SomeValue));
		return null;
	},
	SimpleAlgebraicDatatype.Variant2 variant2 =&gt; _ =&gt;
	{
		Console.Write(Convert.ToString(variant2.SomeValue));
		return null;
	},
	_ =&gt; _ =&gt; throw new Exception(&quot;Unreachable&quot;),
};
action(variant);
</code></pre>
<p>If we use <a href="functional-helpers/./action-to-unit.html">ActionToUnit</a> once again, we can simplify this code, by a lot:</p>
<pre><code class="language-csharp">_ = variant switch
{
	SimpleAlgebraicDatatype.Variant1 variant1 =&gt; ActionToUnit(() =&gt; Console.Write(variant1.SomeValue)),
	SimpleAlgebraicDatatype.Variant2 variant2 =&gt; ActionToUnit(() =&gt; Console.Write(Convert.ToString(variant2.SomeValue))),
};
</code></pre>
<p>If you cannot use the discard syntax (<code>_ =</code>), simply use <code>var _</code> or similar, and ignore the variable after.</p>
<p>The <code>ActionToUnit</code> function wraps a action into a function that returns a <code>Funcky.Unit</code> instance.</p>
<p>You could write this method for yourself like this:</p>
<pre><code class="language-csharp">public static Func&lt;Unit&gt; ActionToUnit(Action action) =&gt; (Func&lt;Unit&gt;) (() =&gt;
{
  action();
  return new Unit(); // or default, or Funcky.Unit.Value
});
</code></pre>
<p>However, if you now wanted a wrapper for a method with a parameter going into the action, you would need to write this:</p>
<pre><code class="language-csharp">public static Func&lt;T, Unit&gt; ActionToUnit&lt;T&gt;(Action&lt;T&gt; action) =&gt; (Func&lt;T, Unit&gt;) (parameter =&gt;
{
  action(parameter);
  return new Unit();
});
</code></pre>
<p>Now with 2 parameters, you would need 2 generic parameters, and so on.
We already support everything from 0 up to 8 in the static class <code>Functional</code>, 
so you can just write <code>using static Funcky.Functional</code> in your using section, and start using <code>ActionToUnit</code>.</p>
<p>For some use cases, see the <a href="functional-helpers/./unit-type.html">Unit Type</a> documentation.</p>
<p>Here one example with a switch expression:</p>
<pre><code class="language-csharp">var value = GetValue();
_ = value switch
{
	&quot;Known&quot; =&gt; ActionToUnit(() =&gt; Console.Write(&quot;Known&quot;)),
	_ =&gt; ActionToUnit(() =&gt; Console.Write(&quot;Unknown&quot;)),
};
</code></pre>
<h1><a class="header" href="#extensions-methods-on-ienumerablet" id="extensions-methods-on-ienumerablet">Extensions-methods on IEnumerable<T></a></h1>
<p>LINQ offers you many important higher order functions to transform IEnumerables in many ways.</p>
<p>Funcky offers a few additional ones which can come in handy.</p>
<!-- toc -->
<h2><a class="header" href="#adjacentgroupby" id="adjacentgroupby">AdjacentGroupBy</a></h2>
<p><img src="enumerable-extensions/adjacent-group-by.svg" alt="adjacent-group-by with marbles" /></p>
<h2><a class="header" href="#averageornone" id="averageornone">AverageOrNone</a></h2>
<h2><a class="header" href="#cartesianproduct" id="cartesianproduct">CartesianProduct</a></h2>
<p>In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A√óB, is the set of all ordered pairs (a, b) where a is in A and b is in B.</p>
<p>The CartesianProduct extension function returns all possible pairs of two given IEnumerables.</p>
<p>There are two overloads, one which lets you choose</p>
<p><img src="enumerable-extensions/cartesian-product.svg" alt="cartesian-product with marbles" title="Marble me!" /></p>
<h3><a class="header" href="#examples" id="examples">Examples</a></h3>
<p>Two sequences as input:</p>
<pre><code>smiles = [üòÄ, üòê, üôÑ]
fruits = [üçâ, üçå, üçá, üçì]
</code></pre>
<p>The cartesian products of smiles and fruits:</p>
<pre><code>smiles √ó fruits =&gt; [[üòÄ, üçâ], [üòÄ, üçå], [üòÄ, üçá], [üòÄ, üçì], 
                    [üòê, üçâ], [üòê, üçå], [üòê, üçá], [üòê, üçì], 
				    [üôÑ, üçâ], [üôÑ, üçå], [üôÑ, üçá], [üôÑ, üçì]]
</code></pre>
<p>In this C# example you see how all Playing cards are in fact a cartesian product of a suit and a value.</p>
<p>This example uses the overload with our own selector, because we just want a sequence of strings.</p>
<pre><code class="language-cs">var suits = ImmutableList.Create(&quot;‚ô†&quot;, &quot;‚ô£&quot;, &quot;‚ô•&quot;, &quot;‚ô¶&quot;);
var values = 
  ImmutableList.Create(&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;T&quot;, &quot;J&quot;, &quot;Q&quot;, &quot;K&quot;, &quot;A&quot;);

var allCards = suits.CartesianProduct(values, (suit, value) =&gt; $&quot;{value}{suit}&quot;);
</code></pre>
<h2><a class="header" href="#chunk" id="chunk">Chunk</a></h2>
<p>With the <code>.Chunk(int)</code> extension method, you can turn an <code>IEnumerable&lt;T&gt;</code> into a <code>IEnumerable&lt;IEnumerable&lt;T&gt;&gt;</code>, with the inner Enumerables being of the given size.
Empty and negative chunk sizes are not allowed and will throw a <code>ArgumentOutOfRangeException</code>.</p>
<p><img src="enumerable-extensions/chunk.svg" alt="chunk with marbles" /></p>
<h3><a class="header" href="#examples-1" id="examples-1">Examples</a></h3>
<pre><code class="language-csharp">var numbers = new List&lt;int&gt; { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
var chunked = numbers.Chunk(3);
// Result: IEnumerable with Chunks of size 3:
// 1st Chunk: 1, 2, 3
// 2nd Chunk: 4, 5, 6
// 3rd Chunk: 7, 8, 9
</code></pre>
<p>When the last chunk isn't complete, we get a smaller, incomplete last chunk:</p>
<pre><code class="language-csharp">var numbers = new List&lt;int&gt; { 1, 2, 3, 4, 5, 6, 7 };
var chunked = numbers.Chunk(4);
// Result: IEnumerable with Chunks of size 4:
// 1st Chunk: 1, 2, 3, 4
// 2nd Chunk: 5, 6, 7
</code></pre>
<p>If required, you can also pass a result selector, that turns the inner IEnumerables into a different type:</p>
<pre><code class="language-csharp">var magicSquare = new List&lt;int&gt; { 4, 9, 2, 3, 5, 7, 8, 1, 6 };
var result = magicSquare.Chunk(3, Enumerable.Average); // equivalent to magicSquare.Chunk(3, number =&gt; Enumerable.Average(number));
// Result: IEnumerable&lt;int&gt; with 5, 5, 5 as items
</code></pre>
<h2><a class="header" href="#foreach" id="foreach">ForEach</a></h2>
<p>With the <code>.ForEach</code> extension method, you can invoke an action for each item in an enumerable, just like a <code>foreach</code> statement would allow you to do.</p>
<p>This method is already available in .NET, but just on <code>List</code>s, and it makes sense for it to be available on every enumerable.</p>
<p>Keep in mind that <code>.ForEach</code> is imperative and only expects an <code>Action&lt;T&gt;</code>. It should not be used to change state of anything outside of the <code>.ForEach</code>.
If you want to combine the enumerable into a result, consider using <code>.Aggregate()</code>, as that is designed for such use-cases.</p>
<h3><a class="header" href="#example" id="example">Example</a></h3>
<pre><code class="language-csharp">// Original
foreach (var item in Items)
{
   DoSomething(item);
}

// Using `.ForEach`
Items.ForEach(DoSomething); // equivalent to Items.ForEach(item =&gt; DoSomething(item));
</code></pre>
<h2><a class="header" href="#firstornone" id="firstornone">FirstOrNone</a></h2>
<h2><a class="header" href="#inspect" id="inspect">Inspect</a></h2>
<p>With the <code>.Inspect</code> extension method, you can invoke an action for each item in an enumerable, 
just like <code>.ForEach</code> or the <code>foreach</code> statement would allow you to do, but the method yields the initial enumerable back.</p>
<p>This can be useful when you want to apply a side-effect to a list before returning, or continue selecting on a list after applying a side-effect.
<code>Inspect</code> can be especially useful when you want to log step(s) of a complex query, since you don't have to change the structure of the code to use it.</p>
<h3><a class="header" href="#examples-2" id="examples-2">Examples</a></h3>
<pre><code class="language-csharp">// Original using .ForEach
var items = someList.Select(TransformSomething);
Items.ForEach(DoSomething);
return items;

// Using `.Inspect`
return someList.Select(TransformSomething).Inspect(DoSomething);
</code></pre>
<pre><code class="language-csharp">// Original using foreach
var items = someList.Select(TransformToSomething);
foreach (var item in items) 
{
  DoSomething(item);
}
var transformedItems = items.Select(TransformToSomethingElse);

// Using `.Inspect`
var transformedItems = someList
  .Select(TransformSomething)
  .Inspect(DoSomething)
  .Select(TransformToSomethingElse);
</code></pre>
<h2><a class="header" href="#deferred-execution" id="deferred-execution">Deferred Execution</a></h2>
<p>It is important to understand at which moment <code>.Inspect</code> is executed. The exact moment of execution is the same as if it were a <code>Select</code>, <code>Where</code> or any other deferred LINQ-method.
See <a href="https://docs.microsoft.com/en-us/dotnet/standard/linq/deferred-execution-lazy-evaluation">Microsoft Docs</a> for more information about deferred execution in LINQ.
This is also an important difference between <code>.ForEach</code> (eager) and <code>.Inspect</code> (deferred).</p>
<p>Consider the following example:</p>
<pre><code class="language-csharp">Enumerable.Range(1, 100)
  .Inspect(n =&gt; Console.WriteLine($&quot;before where: {n}&quot;))
  .Where(n =&gt; n % 2 == 0)
  .Inspect(n =&gt; Console.WriteLine($&quot;after where: {n}&quot;))
  .Inspect(Console.WriteLine)
  .Take(2)
  .ToImmutableList(); // &lt;- Side effects of .Inspect happen here
  
// Prints:
// before where: 1
// before where: 2
// after where: 2
// 2
// before where: 3
// before where: 4
// after where: 4
// 4
</code></pre>
<h2><a class="header" href="#interleave" id="interleave">Interleave</a></h2>
<p><img src="enumerable-extensions/interleave.svg" alt="interleave with marbles" /></p>
<h2><a class="header" href="#intersperse" id="intersperse">Intersperse</a></h2>
<p><img src="enumerable-extensions/intersperse.svg" alt="intersperse with marbles" /></p>
<h2><a class="header" href="#materialize" id="materialize">Materialize</a></h2>
<h2><a class="header" href="#merge" id="merge">Merge</a></h2>
<p><img src="enumerable-extensions/merge.svg" alt="merge with marbles" /></p>
<h3><a class="header" href="#examples-3" id="examples-3">Examples</a></h3>
<p>Given two sequences which are already ordered the same way:</p>
<pre><code>  sequence1 = [1, 2, 7, 9, 14]
  sequence2 = [3, 6, 8, 11, 12, 16]
</code></pre>
<p>By merging we get one single sequence with the all elements of the given sequences with the same order.</p>
<pre><code>  sequence1.Merge(sequence2) =&gt; 
              [1, 2,       7,    9,         14    ]
              [      3, 6,    8,    11, 12,     16]
              -------------------------------------
              [1, 2, 3, 6, 7, 8, 9, 11, 12, 14, 16]
</code></pre>
<h2><a class="header" href="#none" id="none">None</a></h2>
<p>With the <code>.None</code> extension method, you can make <code>!enumerable.Any()</code> calls easier.</p>
<p>That's all there is. You can replace:</p>
<pre><code class="language-csharp">if (!enumerable.Any()) { ... }
</code></pre>
<p>with the easier to read</p>
<pre><code class="language-csharp">if (enumerable.None()) { ... }
</code></pre>
<p>Just like with <code>.Any()</code>, you can additionally pass a predicate as a parameter:</p>
<pre><code class="language-csharp">if (enumerable.None(item =&gt; item.SomeNumericProperty == 2) { ... }
</code></pre>
<h2><a class="header" href="#pairwise" id="pairwise">PairWise</a></h2>
<p><img src="enumerable-extensions/pairwise.svg" alt="pairwise with marbles" /></p>
<h3><a class="header" href="#example-1" id="example-1">Example</a></h3>
<pre><code>animals = [ üêµ, üê∂, üê∫, üê±, ü¶Ñ, üê∑, ü¶Å]
 
animals.PairWise() =&gt;
    [[üêµ, üê∂],
	 [üê∂, üê∫],
	 [üê∫, üê±],
	 [üê±, ü¶Ñ],
	 [ü¶Ñ, üê∑],
	 [üê∑, ü¶Å]]
</code></pre>
<h2><a class="header" href="#partition" id="partition">Partition</a></h2>
<p><img src="enumerable-extensions/partition.svg" alt="partition with marbles" /></p>
<h3><a class="header" href="#example-2" id="example-2">Example</a></h3>
<pre><code>plantBasedFood = [üçâ, üç© , üéÇ, üçå, üç´, üçì, üçí, ü•ï, üåΩ, ü•ß ]

plantBasedFood.Partition(IsProcessedFood?) 
  =&gt; [[üç© , üéÇ, üç´, ü•ß],
      [üçâ, üçå, üçì, üçí, ü•ï, üåΩ]]
</code></pre>
<h2><a class="header" href="#powerset" id="powerset">PowerSet</a></h2>
<p><img src="enumerable-extensions/power-set.svg" alt="power-set with marbles" /></p>
<h2><a class="header" href="#shuffle" id="shuffle">Shuffle</a></h2>
<p><img src="enumerable-extensions/shuffle.svg" alt="shuffle with marbles" /></p>
<h2><a class="header" href="#slidingwindow" id="slidingwindow">SlidingWindow</a></h2>
<p><img src="enumerable-extensions/sliding-window.svg" alt="sliding-window with marbles" /></p>
<h2><a class="header" href="#split" id="split">Split</a></h2>
<p><img src="enumerable-extensions/split.svg" alt="split with marbles" /></p>
<h2><a class="header" href="#takeevery" id="takeevery">TakeEvery</a></h2>
<p><img src="enumerable-extensions/take-every.svg" alt="take-every with marbles" /></p>
<h2><a class="header" href="#transpose" id="transpose">Transpose</a></h2>
<p><img src="enumerable-extensions/transpose.svg" alt="transpose with marbles" /></p>
<h2><a class="header" href="#wherenotnull" id="wherenotnull">WhereNotNull</a></h2>
<p><img src="enumerable-extensions/where-not-null.svg" alt="where-not-null with marbles" /></p>
<h2><a class="header" href="#whereselect" id="whereselect">WhereSelect</a></h2>
<p><img src="enumerable-extensions/where-select.svg" alt="where-select with marbles" /></p>
<h2><a class="header" href="#withfirst" id="withfirst">WithFirst</a></h2>
<p><img src="enumerable-extensions/with-first.svg" alt="with-first with marbles" /></p>
<h2><a class="header" href="#withindex" id="withindex">WithIndex</a></h2>
<p><img src="enumerable-extensions/with-index.svg" alt="with-index with marbles" /></p>
<h2><a class="header" href="#withlast" id="withlast">WithLast</a></h2>
<p><img src="enumerable-extensions/with-last.svg" alt="with-last with marbles" /></p>
<h2><a class="header" href="#withprevious" id="withprevious">WithPrevious</a></h2>
<p><img src="enumerable-extensions/with-previous.svg" alt="with-previous with marbles" /></p>
<h3><a class="header" href="#example-3" id="example-3">Example</a></h3>
<pre><code>animals = [ ü¶Ñ, üê∫, üê∑, ü¶Å, üêµ, üê∂ ]
 
animals.WithPrevious() =&gt;
    [[‚àÖ, ü¶Ñ],
	 [ü¶Ñ, üê∫],
	 [üê∫, üê∑],
	 [üê∑, ü¶Å],
	 [ü¶Å, üêµ],
	 [üêµ, üê∂]]
</code></pre>
<h2><a class="header" href="#ziplongest" id="ziplongest">ZipLongest</a></h2>
<p><img src="enumerable-extensions/zip-longest.svg" alt="zip-longest with marbles" /></p>
<h1><a class="header" href="#string-extensions" id="string-extensions">String Extensions</a></h1>
<h2><a class="header" href="#indexof" id="indexof">IndexOf</a></h2>
<p>The classical <code>IndexOf</code> methods provide a special form of error handling by returning <code>-1</code> when nothing is found.
This is very cumbersome and a potential footgun, since you're not forced to check the return value.</p>
<p>Funcky offers extension methods on <code>string</code> for each overload of <code>IndexOf</code>, <code>IndexOfAny</code>, <code>LastIndexOf</code>, and <code>LastIndexOfAny</code>.
The extension methods follow the simple convention of being suffixed with <code>OrNone</code>.</p>
<pre><code class="language-csharp">Option&lt;string&gt; ParseKey(string input)
    =&gt; input.IndexOfOrNone('[')
         .Select(startIndex =&gt; ParseKeyWithMultipleParts(input, startIndex))
         .GetOrElse(() =&gt; ParseRegularKey(input));
</code></pre>
<p><em>Example usage of <code>IndexOfOrNone</code></em></p>
<h1><a class="header" href="#changelog" id="changelog">Changelog</a></h1>
<p>All notable changes to this project will be documented in this file.
Funcky adheres to <a href="https://semver.org/spec/v2.0.0.html">Semantic Versioning</a>.</p>
<h2><a class="header" href="#unreleased" id="unreleased">Unreleased</a></h2>
<ul>
<li>Add <code>ParseVersionOrNone</code> extension.</li>
<li>Implement <code>Inspect</code> for <code>Either</code> and <code>Result</code>.</li>
<li>Use Source Generator to emit more <code>*OrNone</code> functions.</li>
<li>Cartesian Product deprecated.</li>
<li>Add implicit converions for <code>Either</code> and <code>Result</code>.</li>
</ul>
<h3><a class="header" href="#funckyxunit" id="funckyxunit">Funcky.Xunit</a></h3>
<ul>
<li>Breaking: Funcky.Xunit now uses the <code>Funcky</code> namespace, instead of <code>Funcky.Xunit</code>.</li>
</ul>
<h2><a class="header" href="#funcky-260--funckyanalyzers-100" id="funcky-260--funckyanalyzers-100">Funcky 2.6.0 | Funcky.Analyzers 1.0.0</a></h2>
<h3><a class="header" href="#analyzers" id="analyzers">Analyzers</a></h3>
<p>This release comes with a new package <code>Funcky.Analyzers</code>, which we'll use
to guide users of Funcky</p>
<h3><a class="header" href="#new-extensions" id="new-extensions">New extensions</a></h3>
<ul>
<li>Add extensions <code>DequeueOrNone</code> and <code>PeekOrNone</code> on <code>Queue</code> and <code>ConcurrentQueue</code>.</li>
<li>Add extension <code>ConcatToString</code> as an alias for <code>string.Concat</code>.</li>
<li>Add overload to <code>WhereSelect</code> with no parameter.</li>
<li>Add methods to convert from <code>Either</code> to <code>Option</code>: <a href="https://github.com/polyadic/funcky/issues/439">#439</a>
<ul>
<li><code>LeftOrNone</code>: Returns the left value or <code>None</code> if the either value was right.</li>
<li><code>RightOrNone</code>: Returns the right value or <code>None</code> if the either value was left.</li>
</ul>
</li>
<li>Extension functions for <code>System.Range</code> to allow the generations of <code>IEnumerable&lt;T&gt;</code>s from Range-Syntax:
<pre><code class="language-cs">foreach(var i in 1..5) { }

// negative numbers are not supported
from x in 5..2
from y in 1..3
select (x, y)
</code></pre>
</li>
</ul>
<h3><a class="header" href="#improvements-to-sequence" id="improvements-to-sequence">Improvements to <code>Sequence</code></a></h3>
<ul>
<li><code>Sequence.Return</code> now accepts multiple parameters:
<pre><code class="language-cs">Sequence.Return(1, 2, 3)
</code></pre>
</li>
<li>‚ö†Ô∏è <code>Sequence.Generate</code> has been deprecated in favour of the newly added <code>Sequence.Successors</code> function
which includes the first element (seed) in the generated sequence.</li>
</ul>
<h3><a class="header" href="#improvements-to-option" id="improvements-to-option">Improvements to <code>Option</code></a></h3>
<ul>
<li>Add <code>Option.FromBoolean</code> to create an <code>Option&lt;T&gt;</code> from a boolean.</li>
</ul>
<h3><a class="header" href="#improvements-to-result" id="improvements-to-result">Improvements to <code>Result</code></a></h3>
<p>The behaviour of the <code>Result.Error</code> constructor has been changed regarding exceptions
with an already set stack trace. The original stack trace is now preserved.
Previously this resulted in the stacktrace being replaced (.NET &lt; 5.0) or an error (.NET ‚â• 5.0).</p>
<h3><a class="header" href="#improvements-to-either" id="improvements-to-either">Improvements to <code>Either</code></a></h3>
<ul>
<li>Add <code>Either.Flip</code> to swaps left with right.</li>
</ul>
<h3><a class="header" href="#tooling" id="tooling">Tooling</a></h3>
<ul>
<li>Funcky automatically adds global usings for the most important namespaces of funcky
when the <code>FunckyImplicitUsings</code> property is set. This requires .NET SDK ‚â• 6.0 and C# ‚â• 10.0.</li>
<li>Funcky now supports <a href="https://docs.microsoft.com/en-us/dotnet/core/deploying/trimming/trim-self-contained">trimming</a> for self-contained deployments.</li>
<li><code>Option&lt;T&gt;</code> now works with the new <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-source-generation?pivots=dotnet-6-0">System.Text.Json source generation</a>.</li>
<li>The <code>Funcky</code> package now supports <a href="https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/sourcelink">Source Link</a> and deterministic builds.</li>
<li>The symbols package is now finally working again.</li>
</ul>
<h2><a class="header" href="#funcky-250" id="funcky-250">Funcky 2.5.0</a></h2>
<h3><a class="header" href="#reader-monad" id="reader-monad">Reader Monad</a></h3>
<p>This release includes the <code>Reader</code> monad including a bunch of factory methods
and convenience extensions.</p>
<pre><code class="language-cs">public static Reader&lt;Enviroment, IEnumerable&lt;string&gt;&gt; DefaultLayout(IEnumerable&lt;DateTime&gt; month)
    =&gt; from colorizedMonthName in ColorizedMonthName(month)
       from weekDayLine in WeekDayLine()
       from weeksInMonth in month
        .GroupBy(GetWeekOfYear)
        .Select(FormatWeek)
        .Sequence()
       select BuildDefaultLayout(colorizedMonthName, weekDayLine, weeksInMonth);
</code></pre>
<h3><a class="header" href="#improved-action-extensions" id="improved-action-extensions">Improved <code>Action</code> Extensions</a></h3>
<p>Funcky now supports <code>Curry</code>, <code>Uncurry</code> and <code>Flip</code> for <code>Action</code>s too. <br />
This release also adds the inversion of <code>ActionToUnit</code>: <code>UnitToAction</code></p>
<h3><a class="header" href="#more-extensions-for-ienumerablet" id="more-extensions-for-ienumerablet">More Extensions for <code>IEnumerable&lt;T&gt;</code></a></h3>
<ul>
<li><code>Intersperse</code>: Adds a given item in between all items of an enumerable.</li>
<li><code>JoinToString</code>: Alias for <code>string.Join</code>.</li>
<li><code>WithPrevious</code>: Similar to <code>WithFirst/Last/Index</code> but with the predecessor of each item.</li>
<li><code>ForEach</code>: Add an overload to <code>ForEach</code> that accepts a <code>Unit</code>-returning <code>Func</code>.</li>
</ul>
<h3><a class="header" href="#additional-factory-methods" id="additional-factory-methods">Additional Factory Methods</a></h3>
<ul>
<li><code>EitherOrBoth.FromOptions</code> creates an <code>EitherOrBoth</code> from two options.</li>
<li><code>Lazy.FromFunc</code> creates a <code>Lazy&lt;T&gt;</code> from a <code>Func</code>. <br />
This is sugar over the <code>Lazy&lt;T&gt;</code> constructor, with the additional benefit of supporting type inference.</li>
<li><code>Lazy.Return</code> creates a <code>Lazy&lt;T&gt;</code> from a value. <br />
This is sugar over the <code>Lazy&lt;T&gt;</code> constructor, with the additional benefit of supporting type inference.</li>
</ul>
<h3><a class="header" href="#documentation-improvements" id="documentation-improvements">Documentation Improvements</a></h3>
<p>This release comes with a few small documentation improvements.
Funcky users will now also see the <code>[Pure]</code> attributes which were previously not emitted.</p>
<h2><a class="header" href="#funcky-241" id="funcky-241">Funcky 2.4.1</a></h2>
<ul>
<li>Remove upper bounds on all Microsoft.Bcl.* dependencies.
Between the 2.3.0 and 2.4.0 release an overly restrictive upper bound was accidentally introduced for Microsoft.Bcl.AsyncInterfaces.</li>
</ul>
<h2><a class="header" href="#funcky-240" id="funcky-240">Funcky 2.4.0</a></h2>
<h3><a class="header" href="#try--ornone" id="try--ornone"><code>Try*</code> ‚Üí <code>*OrNone</code></a></h3>
<p>We've renamed all <code>Try*</code> methods, such as <code>TryParse</code>, <code>TryGet</code> value to <code>*OrNone</code>.
The old methods are still available, but marked as obsolete and will be removed in 3.0.0.</p>
<h3><a class="header" href="#factory-methods-for-ienumerablet" id="factory-methods-for-ienumerablet">Factory methods for <code>IEnumerable&lt;T&gt;</code></a></h3>
<p>This release adds some new factory methods for creating <code>IEnumerable&lt;T&gt;</code>
to the <code>Sequence</code> class:</p>
<ul>
<li><code>Sequence.RepeatRange</code>: Generates a sequence that contains the same sequence of elements the given number of times</li>
<li><code>Sequence.Cycle</code>: Cycles the same element over and over again as an endless generator.</li>
<li><code>Sequence.CycleRange</code>: Generates a sequence that contains the same sequence of elements over and over again as an endless generator</li>
<li><code>Sequence.Concat</code></li>
</ul>
<h3><a class="header" href="#more-extension-methods" id="more-extension-methods">More Extension Methods</a></h3>
<h4><a class="header" href="#for-ienumerablet" id="for-ienumerablet">for <code>IEnumerable&lt;T&gt;</code></a></h4>
<ul>
<li><code>Materialize</code>: Materializes all the items of a lazy enumerable.</li>
<li><code>PowerSet</code>: Returns a sequence with the set of all subsets</li>
<li><code>Shuffle</code>: Returns the given sequence in random Order in O(n).</li>
<li><code>Split</code>: Splits the source sequence a separator.</li>
<li><code>ZipLongest</code>: Zips two sequences with different lengths.</li>
</ul>
<h4><a class="header" href="#for-string" id="for-string">for <code>string</code></a></h4>
<ul>
<li><code>SplitLazy</code>: Splits a string by separator lazily.</li>
<li><code>SplitLines</code>: Splits a string by newline lazily.</li>
</ul>
<h4><a class="header" href="#for-func" id="for-func">for <code>Func</code></a></h4>
<ul>
<li><code>Curry</code></li>
<li><code>Uncurry</code></li>
<li><code>Flip</code></li>
<li><code>Compose</code></li>
</ul>
<h3><a class="header" href="#eitherorboth" id="eitherorboth"><code>EitherOrBoth</code></a></h3>
<p>EitherOrBoth is a new data type that can represent <code>Left</code>, <code>Right</code> and <code>Both</code>. It is used in <code>ZipLongest</code>.</p>
<h3><a class="header" href="#monadreturn" id="monadreturn"><code>Monad.Return</code></a></h3>
<p>This release adds a <code>Return</code> method for all monad types in Funcky:</p>
<ul>
<li><code>Option.Return</code></li>
<li><code>Either&lt;TLeft&gt;.Return</code></li>
<li><code>Result.Return</code></li>
</ul>
<h3><a class="header" href="#optionequalitycomparer" id="optionequalitycomparer"><code>OptionEqualityComparer</code></a></h3>
<p>To support more advanced comparison scenarios, <code>OptionEqualityComparer</code> has been added similar to the already existing <code>OptionComparer</code>.</p>
<h3><a class="header" href="#smaller-improvements" id="smaller-improvements">Smaller Improvements</a></h3>
<ul>
<li>Added a missing <code>Match</code> overload to <code>Either</code> that takes <code>Action</code>s</li>
<li>Added additional overloads for <code>Functional.True</code> and <code>Functional.False</code> for up to four parameters.</li>
</ul>
<h2><a class="header" href="#funcky-230" id="funcky-230">Funcky 2.3.0</a></h2>
<ul>
<li><code>net5.0</code> has been added to Funcky's target frameworks.</li>
</ul>
<h3><a class="header" href="#improvements-to-optiont" id="improvements-to-optiont">Improvements to <code>Option&lt;T&gt;</code></a></h3>
<ul>
<li><code>Option&lt;T&gt;</code> is now implicitly convertible from <code>T</code>.
<pre><code class="language-csharp">public static Option&lt;int&gt; Answer =&gt; 42;
</code></pre>
</li>
<li><code>Option</code> adds support for <code>System.Text.Json</code>:<br />
The custom <code>JsonConverter</code> is picked up automatically when serializing/deserializing.
<code>None</code> is serialized as <code>null</code> and <code>Some(value)</code> is serialized to whatever <code>value</code> serializes to.</li>
</ul>
<h3><a class="header" href="#factory-methods-for-ienumerablet-1" id="factory-methods-for-ienumerablet-1">Factory methods for <code>IEnumerable&lt;T&gt;</code></a></h3>
<p>This release adds factory methods for creating <code>IEnumerable&lt;T&gt;</code>
with the static class <code>Sequence</code>:</p>
<ul>
<li><code>Sequence.Return</code>: Creates an <code>IEnumerable&lt;T&gt;</code> with exactly one item.</li>
<li><code>Sequence.FromNullable</code>: Creates an <code>IEnumerable&lt;T&gt;</code> with zero or one items.</li>
<li><code>Sequence.Generate</code>: Creates an <code>IEnumerable&lt;T&gt;</code> using a generation function and a seed.</li>
</ul>
<h3><a class="header" href="#more-extension-methods-for-ienumerablet" id="more-extension-methods-for-ienumerablet">More Extension Methods for <code>IEnumerable&lt;T&gt;</code></a></h3>
<p>This release adds a bunch of new extension methods on <code>IEnumerable&lt;T&gt;</code>:</p>
<ul>
<li><code>AdjacentGroupBy</code></li>
<li><code>AverageOrNone</code></li>
<li><code>CartesianProduct</code></li>
<li><code>Chunk</code></li>
<li><code>ElementAtOrNone</code></li>
<li><code>Interleave</code></li>
<li><code>MaxOrNone</code></li>
<li><code>Merge</code></li>
<li><code>MinOrNone</code></li>
<li><code>Pairwise</code></li>
<li><code>Partition</code></li>
<li><code>SlidingWindow</code></li>
<li><code>TakeEvery</code></li>
<li><code>Transpose</code></li>
<li><code>WithFirst</code></li>
<li><code>WithIndex</code></li>
<li><code>WithLast</code></li>
</ul>
<h3><a class="header" href="#iasyncenumerablet-support" id="iasyncenumerablet-support"><code>IAsyncEnumerable&lt;T&gt;</code> Support</a></h3>
<p>This release adds a couple of extension methods that provide interoperability
with <code>Option&lt;T&gt;</code> to <code>IAsyncEnumerable&lt;T&gt;</code>:</p>
<ul>
<li><code>WhereSelect</code></li>
<li><code>FirstOrNoneAsync</code></li>
<li><code>LastOrNoneAsync</code></li>
<li><code>SingleOrNoneAsync</code></li>
<li><code>ElementAtOrNoneAsync</code></li>
</ul>
<p>A couple of the new extension methods on <code>IEnumerable&lt;T&gt;</code> have async counterparts:</p>
<ul>
<li><code>Pairwise</code></li>
<li><code>TakeEvery</code></li>
</ul>
<p>The naming of the extension methods and their overloads follows that of <a href="https://github.com/dotnet/reactive/tree/main/Ix.NET/Source/System.Linq.Async"><code>System.Linq.Async</code></a>.</p>
<h3><a class="header" href="#improved-iqueryable-support" id="improved-iqueryable-support">Improved <code>IQueryable</code> Support</a></h3>
<p>This release adds specialized extension methods for <code>IQueryable&lt;T&gt;</code> that are better
suited especially for use with EF Core:</p>
<ul>
<li><code>FirstOrNone</code></li>
<li><code>LastOrNone</code></li>
<li><code>SingleOrNone</code></li>
</ul>
<h3><a class="header" href="#dependencies" id="dependencies">Dependencies</a></h3>
<p>To support .NET Standard, Funcky conditionally pulls in dependencies
that provide the missing functionality:</p>
<ul>
<li><code>Microsoft.Bcl.AsyncInterfaces</code> for .NET Standard 2.0</li>
<li><code>System.Collections.Immutable</code> and <code>System.Text.Json</code> for .NET Standard 2.0 and 2.1</li>
<li>The version constraints for all these packages have been relaxed to allow 5.x.</li>
</ul>
<h3><a class="header" href="#improvements" id="improvements">Improvements</a></h3>
<ul>
<li><code>ConfigureAwait(false)</code> is now used everywhere <code>await</code> is used.</li>
<li>The <code>IRetryPolicy</code> implementations now use correct <code>Timespan</code> with <code>double</code> multiplication
when targeting .NET Standard 2.0.</li>
</ul>
<h3><a class="header" href="#deprecations" id="deprecations">Deprecations</a></h3>
<ul>
<li><code>ObjectExtensions.ToEnumerable</code> has been deprecated in favor of <code>Sequence.FromNullable</code>.</li>
<li><code>RequireClass</code> and <code>RequireStruct</code> have been obsoleted with no replacement.</li>
</ul>
<h2><a class="header" href="#funcky-220--funckyxunit-013" id="funcky-220--funckyxunit-013">Funcky 2.2.0 | Funcky.xUnit 0.1.3</a></h2>
<ul>
<li>Added overload to <code>Functional.Retry</code> with a <code>IRetryPolicy</code>.</li>
<li>Added <code>None</code> overload that takes no predicate.</li>
</ul>
<h2><a class="header" href="#funcky-211--funckyxunit-012" id="funcky-211--funckyxunit-012">Funcky 2.1.1 | Funcky.xUnit 0.1.2</a></h2>
<ul>
<li>Re-release of previous release with correct assemblies.</li>
</ul>
<h2><a class="header" href="#funcky-210--funckyxunit-011" id="funcky-210--funckyxunit-011">Funcky 2.1.0 | Funcky.xUnit 0.1.1</a></h2>
<ul>
<li>Add <code>Inspect</code> method to <code>Option</code> akin to <code>IEnumerable.Inspect</code>.</li>
<li>Add <code>ToTheoryData</code> extension for <code>IEnumerable&lt;T&gt;</code> for xUnit.</li>
<li>Add <code>Unit.Value</code> as a way to a get a <code>Unit</code> value.</li>
<li>Add <code>Functional.Retry</code> which retries a producer until <code>Option.Some</code> is returned.</li>
</ul>
<h2><a class="header" href="#funcky-200" id="funcky-200">Funcky 2.0.0</a></h2>
<h3><a class="header" href="#breaking-changes" id="breaking-changes">Breaking Changes</a></h3>
<ul>
<li>Remove <code>Reader</code> monad based on <code>await</code>.</li>
<li>Remove <code>IToString</code>.</li>
<li>Remove overload for <code>Option.From</code> that flattens passed <code>Option</code>s.</li>
<li>Move <code>ToEnumerable</code> extension method to its own class.
This is only a breaking change if you've used the extension method as normal method.
In that case you need to change <code>EnumerableExtensions.ToEnumerable</code> to <code>ObjectExtensions.ToEnumerable</code>.</li>
<li>Rename <code>Option.From</code> to <code>Option.FromNullable</code> and remove overload that takes non-nullable value types.</li>
<li>Unify <code>Option&lt;T&gt;.ToEnumerable</code> and <code>Yield</code> to <code>ToEnumerable</code></li>
<li>Rename <code>OrElse</code> overloads that return the item to <code>GetOrElse</code> which improves overload resolution.</li>
<li>The <code>Each</code> extension method on <code>IEnumerable&lt;T&gt;</code> has been renamed to <code>ForEach</code>.</li>
<li>Move the <code>Ok</code> constructor of <code>Result&lt;T&gt;</code> to a non-generic class. This allows for the compiler to infer the generic type.
Old: <code>Result&lt;int&gt;.Ok(10)</code>. New: <code>Result.Ok(10)</code>.</li>
<li>Use <code>Func&lt;T, bool&gt;</code> instead of <code>Predicate&lt;T&gt;</code> in predicate composition functions (<code>Functional.All</code>, <code>Functional.Any</code>, <code>Functional.Not</code>),
because most APIs in <code>System</code> use <code>Func</code>.</li>
<li><code>Functional.Any</code> now returns <code>false</code> when the given list of predicates is empty.</li>
</ul>
<h3><a class="header" href="#fixes" id="fixes">Fixes</a></h3>
<ul>
<li>Fix incorrect <code>Equals</code> implementation on <code>Option</code>.
<code>Equals</code> previously returned <code>true</code> when comparing a <code>None</code> value with a <code>Some</code> value containing the default value of the type.</li>
<li><code>Exception</code> created by <code>Result</code> monad contains valid stack trace</li>
<li>Fix incorrect implementation on <code>Result.SelectMany</code> which called the <code>selectedResultSelector</code> even when the
result was an error. As a result (pun intended) of the fix, <code>ResultCombinationException</code> is no longer needed and also removed.</li>
</ul>
<h3><a class="header" href="#additions" id="additions">Additions</a></h3>
<ul>
<li>Add <code>IndexOfOrNone</code>, <code>LastIndexOfOrNone</code>, <code>IndexOfAnyOrNone</code> and <code>LastIndexOfAnyOrNone</code> extension methods to <code>string</code>.</li>
<li>Added <code>Curry</code>, <code>Uncurry</code> and <code>Flip</code> to the <code>Functional</code> Class</li>
<li>Add extension method for <code>HttpHeaders.TryGetValues</code>, which returns an <code>Option</code>.</li>
<li>Add extension methods for getting <code>Stream</code> properties that are not always available, as <code>Option</code>:
<code>GetLengthOrNone</code>, <code>GetPositionOrNone</code>, <code>GetReadTimeoutOrNone</code>, <code>GetWriteTimeoutOrNone</code>.</li>
<li>Add <code>None</code> extension method to <code>IEnumerable</code>.</li>
<li><code>Option&lt;Task&lt;T&gt;&gt;</code>, <code>Option&lt;Task&gt;</code> and their <code>ValueTask</code> equivalents are now awaitable:
<pre><code class="language-csharp">var answer = await Option.Some(Task.FromResult(42));
</code></pre>
</li>
</ul>
<h3><a class="header" href="#improvements-1" id="improvements-1">Improvements</a></h3>
<ul>
<li>Full nullable support introduced with C# 8.</li>
<li>Mark our functions as <code>[Pure]</code>.</li>
<li>Implement <code>IEquatable</code> on <code>Option</code>, <code>Result</code> and <code>Either</code>.</li>
</ul>
<h2><a class="header" href="#funcky-200-rc2" id="funcky-200-rc2">Funcky 2.0.0-rc.2</a></h2>
<ul>
<li>Move the <code>Ok</code> constructor of <code>Result&lt;T&gt;</code> to a non-generic class. This allows for the compiler to infer the generic type.
Old: <code>Result&lt;int&gt;.Ok(10)</code>. New: <code>Result.Ok(10)</code>.</li>
<li>Add <code>IndexOfOrNone</code>, <code>LastIndexOfOrNone</code>, <code>IndexOfAnyOrNone</code> and <code>LastIndexOfAnyOrNone</code> extension methods to <code>string</code>.</li>
<li>Rename <code>OrElse</code> overloads that return the item to <code>GetOrElse</code> which improves overload resolution.</li>
<li>Added <code>Curry</code>, <code>Uncurry</code> and <code>Flip</code> to the <code>Functional</code> Class</li>
<li>Remove <code>IToString</code>.</li>
<li>Mark our functions as <code>[Pure]</code>.</li>
<li>Fix incorrect implementation on <code>Result.SelectMany</code> which called the <code>selectedResultSelector</code> even when the
result was an error. As a result (pun intended) of the fix, <code>ResultCombinationException</code> is no longer needed and also removed.</li>
</ul>
<h2><a class="header" href="#funcky-200-rc1" id="funcky-200-rc1">Funcky 2.0.0-rc.1</a></h2>
<ul>
<li>Full nullable support introduced with C# 8</li>
<li>Rename <code>Option.From</code> -&gt; <code>Option.FromNullable</code> and remove overload that takes non-nullable value types.</li>
<li>Use <code>Func&lt;T, bool&gt;</code> instead of <code>Predicate&lt;T&gt;</code> in predicate composition functions (<code>Functional.All</code>, <code>Functional.Any</code>, <code>Functional.Not</code>),
because most APIs in <code>System</code> use <code>Func</code>.</li>
<li><code>Functional.Any</code> now returns <code>false</code> when the given list of predicates is empty.</li>
<li>The <code>Each</code> extension method on <code>IEnumerable&lt;T&gt;</code> has been renamed to <code>ForEach</code>.</li>
<li>Unify <code>Option&lt;T&gt;.ToEnumerable</code> and <code>Yield</code> to <code>ToEnumerable</code></li>
<li>Remove <code>Reader</code> monad based on <code>await</code>.</li>
<li><code>Exception</code> created by <code>Result</code> monad contains valid stack trace</li>
</ul>
<h2><a class="header" href="#funcky-180" id="funcky-180">Funcky 1.8.0</a></h2>
<ul>
<li>Added overload for <code>AndThen</code> which flattens the <code>Option</code></li>
<li>Add <code>Where</code> method to <code>Option&lt;T&gt;</code>, which allows filtering the <code>Option</code> by a predicate.</li>
<li>Add overload for <code>Option&lt;T&gt;.SelectMany</code> that takes only a selector.</li>
<li>Add <code>WhereNotNull</code> extension method for <code>IEnumerable&lt;T&gt;</code>.</li>
</ul>
<h2><a class="header" href="#funcky-170" id="funcky-170">Funcky 1.7.0</a></h2>
<ul>
<li>Add nullability annotations to everything except for <code>Monads.Reader</code>.</li>
<li>Add a function for creating an <code>Option&lt;T&gt;</code> from a nullable value: <code>Option.From</code>.</li>
<li><code>Either.Match</code> now throws when called on an <code>Either</code> value created using <code>default(Either&lt;L, R&gt;)</code>.</li>
<li>Add <code>True</code> and <code>False</code> functions to public API</li>
<li>Match of <code>Result</code> Monad accepts actions</li>
<li>Add <code>FirstOrNone</code>, <code>LastOrNone</code> and <code>SingleOrNone</code> extension functions</li>
</ul>
<h2><a class="header" href="#funcky-160" id="funcky-160">Funcky 1.6.0</a></h2>
<ul>
<li>Add ToEnumerable function to <code>Option&lt;T&gt;</code>.</li>
<li>Add <code>WhereSelect</code> extension function for <code>IEnumerable&lt;T&gt;</code>.</li>
<li>Add missing overload for nullary actions to <code>ActionToUnit</code>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
